# In [1]:

pd = import '/pandas'
plt = import '/matplotlib/pyplot'
mpatches = import '/matplotlib/patches'
load_breast_cancer = import '/sklearn/datasets/load_breast_cancer'

# ---

# In [--]:
# Yapılandırmalar:
showGraphicalContent = False

# ---

# In [2]:

# Veri setini yükleme:
cancer = load_breast_cancer!

# Ortalama Textile
x = (map (!! 1) cancer.data) |> list
# 0: Kötü Huylu,
# 1: İyi Huylu:
y = cancer.target

# ---

# In [3]:
#CHN {Python gerçeklemesinde önerdiğim şekilde,
#     edgecolors için daha öz bir hesaplama yapıyoruz.}

colors = {(0, 'red'), (1, 'blue')}
plt.scatter x y facecolors: 'none' edgecolors: ((map (x -> colors !! x) cancer.target) |> list) cmap: colors
plt.xlabel "Ortalama Texture"
plt.ylabel "Sonuç"

red = mpatches.Patch color: 'red' label: 'Kötü Huylu'
blue = mpatches.Patch color: 'blue' label: 'İyi Huylu'
plt.legend handles: [red, blue] loc: 1

showGraphicalContent and plt.show!

# ---

# In [4]:

#CHN{linear_model nesnesinin bir kez kullanımı üzerine, kullanımı elemine etmek için çağrımı ekleme
#    kütüphanenin eklenmesi ifadesinde çözümledik}
#ADD{Numpy kütüphanesinin çağırımsız kullanımını düzeltmek için, deklarasyon yapıldı}

LogisticRegression = import '/sklearn/linear_model/LogisticRegression'
np = import '/numpy'

# ---

# In [5]:

#RNM{log_regress:lojistik_regresyon}

lojistik_regresyon = LogisticRegression!
#np.array(x).reshape(len(x), 1),
lojistik_regresyon.fit X: ((np.array x) |>.reshape (len x) 1) y: y

# ---

# In [6]:

print lojistik_regresyon.intercept_
print lojistik_regresyon.coef_

# ---

# In [7]:

sigmoid = x ->
        1 / (1 + (np.exp (- ((lojistik_regresyon.intercept_ !! 0) + ((lojistik_regresyon.coef_ |> (!! 0) |> (!! 0)) * x)))))

# ---

# In [8]:

x1 = np.arange 0 30 0.01
y1 = (map sigmoid x1) |> list

# ---

# In [9]:

plt.scatter x y facecolors: 'none' edgecolors: ((map (x -> colors !! x) cancer.target) |> list) cmap: colors
plt.plot x1 y1
plt.xlabel "Ortalama Texture"
plt.ylabel "Olasılık"

showGraphicalContent and plt.show!

# ---

# In [10]:
#SUG{np.array([30]).reshape(1, 1):[[30]], double question-mark (??)}

# ____$'dan sonrasını parantez içinde hayal edin.
print $ lojistik_regresyon.predict_proba [[30]]
print $ lojistik_regresyon.predict [[30]]

# ---

# In [11]:
#SUG{np.array([10]).reshape(1, 1):[[10]], double question-mark (??)}

# Yukarıdaki gibi,
# ____$'dan sonrasını parantez içinde hayal edin.
print $ lojistik_regresyon.predict_proba [[10]]
print $ lojistik_regresyon.predict [[10]]

# ---

# In [12]:

# Daha fazla özellik kullanarak modeli eğitmek için;
# eğitim seti için, veri setinin %80'i hedef değişkene göre rastgele seçilirse:

train_test_split = import '/sklearn/model_selection/train_test_split'
LinearRegression = import '/sklearn/linear_model/LinearRegression'
metrics = import '/sklearn/metrics'

# ---

# In [13]:
#RNM{train_set:eğitim_seti}
#RNM{test_set:test_seti}
#RNM{train_labels:eğitim_etiketleri}
#RNM{test_labels:test_etiketleri}

[eğitim_seti, test_seti, eğitim_etiketleri, test_etiketleri] =
    # ____________________________________________________________ hedef değişkene göre tesadüfilik:
    train_test_split cancer.data cancer.target test_size: 0.2 random_state: 1 stratify: cancer.target

# ---

# In [14]:
#RNM{log_regress:lojistik_regresyon_hdg, lojist_regresyon önceden tanımlı,
#    bir son-ek ile yeniden tanımlandı.}
#NEW{Görünüşe göre, Lojistik Regresyon sürecindeki varsayılan çözümleyici (hesaplayıcı, algoritma)
#    Limited-memory Broyden–Fletcher–Goldfarb–Shanno Algorithm (lbfgs), total iterasyon limitine
#    takılıyor. Varsayılan maksimum iterasyon değerini (100), 2500 olarak tanımlandı.

# İlk on (10) özellik seçimi:
x = (map (i -> take 30 i) eğitim_seti) |> (bind map list) |> list
# 0: Kötü Huylu,
# 1: İyi Huylu:
y = eğitim_etiketleri
# Hedef değişkene göre (hdg), Lojistik Regresyon değişkeni:
lojistik_regresyon_hdg = LogisticRegression max_iter: 2500
lojistik_regresyon_hdg.fit X: x y: y

# ---

# In [15]:

print lojistik_regresyon_hdg.intercept_
print lojistik_regresyon_hdg.coef_

# ---

# In [16]:
#CHN{Panda, Notdefterine önceden eklendiği için yeniden içerleme yapılmadı.}
#RNM{preds_proba:tahmin_olasılıkları}
#RNM{preds_class:tahmin_sınıfları}
#RNM{original_result:orijinal_sonuçlar}
#RNM{result:sonuç}

tahmin_olasılıkları = pd.DataFrame $ lojistik_regresyon_hdg.predict_proba X: test_seti
tahmin_olasılıkları.columns = ["Malignant", "Benign"]

tahminler = lojistik_regresyon_hdg.predict X: test_seti
tahmin_sınıfları = pd.DataFrame tahminler
tahmin_sınıfları.columns = ["Tahmin"]

orijinal_sonuçlar = pd.DataFrame test_etiketleri
orijinal_sonuçlar.columns = ["Orijinal Sonuç"]

#Üç veri çerçevesini 1 veri çerçevesine indirgeme:
sonuç = pd.concat [tahmin_olasılıkları, tahmin_sınıfları, orijinal_sonuçlar] axis: 1
print $ sonuç.head 15

# ---

# In [17]:

print "----Karışıklık Matrisi----"
print $ pd.crosstab tahminler test_etiketleri

# ---

# In [18]:

print '----Doğruluk (Accuracy)----'
print $ lojistik_regresyon_hdg.score X: test_seti y: test_etiketleri

# ---

# In [19]:

#NEW{Başlık ortalandı.}

print "         ----------Metriksler----------         "
print $
    metrics.classification_report y_true: test_etiketleri y_pred: tahminler

# ---

# In [20]:
#AUC ÖRNEĞİ***
#NEW{Örneğe bağlı temel değişkenler bu örnekten çıkarılacak.
#    Tahmin_olasılıkları_ ve tahminler_ değerleri örnek özelinde,
#    önceden elde ettiğimiz tahmin nesnesi üzerinden oluşturulmuştur.

tahmin_olasılıkları_ = lojistik_regresyon_hdg.predict_proba X: test_seti
tahminler_ = (map (i -> take 1 i) tahmin_olasılıkları_) |> list |> np.array

[fpr, tpr, threshold] = metrics.roc_curve test_etiketleri tahminler_

# ---
